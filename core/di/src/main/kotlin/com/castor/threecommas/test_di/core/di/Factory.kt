package com.castor.threecommas.test_di.core.di

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

// https://habr.com/ru/company/wrike/blog/569918/
/***
 * В принципе, этот подход работает, но в нем есть скрытая опасность.
 * Допустим, мы используем ViewModel для сохранения какого-то утилитарного класса
 * при повороте экрана (например, Router), а этот класс имеет конструктор,
 * помеченный аннотацией @Inject, и наследует от ViewModel.
 * Тогда мы можем, не глядя в код Router, добавить его как параметр в конструктор вьюмодели:
 *
 * Что произойдет в таком случае? Router будет создан вместе с вьюмоделью и
 * заинжекчен в ее конструктор, ничего необычного. Но когда будет вызван метод onCleared()
 * вьюмодели, этот же метод не будет вызван для Router.
 * Это может потенциально привести к утечке памяти или еще более неприятным
 * и сложным к поимке багам.
 *
 * Обратите внимание, что то же самое может произойти, если заинжектить и
 * более очевидную вьюмодель внутрь вьюмодели. Не очень корректно использовать
 * их таким образом, но лучший подход не оставляет места для ошибки,
 * иначе мы бы использовали Koin или другой сервис-локатор вместо Dagger
 * и не беспокоились бы о таких вещах.
 *
 * Как же избежать этой проблемы? Например, использовать @AssistedInject.
 */
class Factory<T : ViewModel>(private val create: () -> T) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T =
        create.invoke() as T
}
